{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/CountingSet.ts", "../../src/Container.ts", "../../src/Injected.ts"],
  "sourcesContent": ["export { Container, Instance } from \"./Container\"\nexport { Injected } from \"./Injected\"\n", "export class CountingSet<T> {\n  private readonly _map = new Map<T, number>()\n  private readonly _set = new Set<T>()\n\n  add(value: T): this {\n    const count = this._map.get(value) || 0\n    this._map.set(value, count + 1)\n    this._set.add(value)\n    return this\n  }\n\n  delete(value: T): boolean {\n    if (this._map.has(value)) {\n      const count = this._map.get(value)!\n      if (count > 1) {\n        this._map.set(value, count - 1)\n      } else {\n        this._map.delete(value)\n        this._set.delete(value)\n      }\n      return true\n    }\n    return false\n  }\n\n  has(value: T): boolean {\n    return this._set.has(value)\n  }\n\n  count(value: T): number {\n    return this._map.get(value) || 0\n  }\n\n  clear(): void {\n    this._map.clear()\n    this._set.clear()\n  }\n\n  get size(): number {\n    return this._set.size\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    return this._set[Symbol.iterator]()\n  }\n\n  forEach(\n    callbackfn: (value: T, value2: T, set: Set<T>) => void,\n    thisArg?: any\n  ): void {\n    this._set.forEach(callbackfn, thisArg)\n  }\n}\n", "import { CountingSet } from \"./CountingSet\"\n\nexport type Context = {\n  [key: string]: unknown\n}\n\nexport type Instance<TValue> = {\n  new (context: any, ...args: any[]): TValue\n}\n\ntype Flatten<T> = {} & { [P in keyof T]: T[P] }\n\ntype MergeContext<TExisting, TKey extends string, TValue> = Flatten<\n  TExisting & {\n    [P in TKey]: TValue\n  }\n>\n\ntype RegistrationOptions = {\n  transient?: boolean\n}\n\nexport class Container<TContext extends Context = {}> {\n  private _registry: Map<string, unknown> = new Map<string, unknown>()\n  private _resolvers: Map<\n    string,\n    (context: TContext, resolved: CountingSet<unknown>) => unknown\n  > = new Map<string, (context: TContext) => unknown>()\n  private _transient: Set<string> = new Set<string>()\n\n  constructor(private _parentContainer?: Container<TContext>) {}\n\n  static build<T extends Context = {}>(): Container<T> {\n    return new Container<T>()\n  }\n\n  copy<TContext>(rootContext: Context = {}): TContext {\n    // Get all of the keys in the map\n    const keys = Array.from(this._resolvers.keys())\n\n    // Create an object that either has the value from the root context, the value from the registry\n    // or gets the value from the map's generator.\n    const context = keys.reduce((acc: Record<string, unknown>, key) => {\n      if (rootContext.hasOwnProperty(key)) {\n        acc[key] = rootContext[key]\n      } else if (this._registry.has(key)) {\n        acc[key] = this._registry.get(key)\n      } else {\n        acc[key] = this.resolve(key)\n      }\n\n      return acc\n    }, {}) as TContext\n\n    return {\n      ...context,\n      ...rootContext,\n    } as TContext\n  }\n\n  context<TWriteContext extends Context = TContext>(\n    rootContext: Context = {},\n    resolved: CountingSet<unknown> = new CountingSet<unknown>()\n  ): TWriteContext {\n    const cache: Record<string, unknown> = {}\n\n    const handler = {\n      get: (target: TContext, key: string) => {\n        if (cache.hasOwnProperty(key)) return cache[key]\n        if (target.hasOwnProperty(key)) return target[key]\n        return this.resolve(key, resolved)\n      },\n      set: (_target: Context, key: string, value: unknown) => {\n        cache[key] = value\n        return true\n      },\n    }\n\n    const proxy = new Proxy<TContext>(rootContext as TContext, handler)\n\n    return proxy as unknown as TWriteContext\n  }\n\n  // Add a subcontext to a property of this context\n  group<TNewKey extends string, TNewContext extends Context>(\n    key: TNewKey,\n    decorator: (container: Container<TContext>) => Container<TNewContext>\n  ): Container<MergeContext<TContext, TNewKey, TNewContext>> {\n    const nestedContainer = new Container(this._parentContainer ?? this)\n    const value = decorator(nestedContainer).context()\n    this.register(key, () => value)\n    return this as any\n  }\n\n  static group<TNewKey extends string, TNewContext extends Context>(\n    key: TNewKey,\n    decorator: (container: Container<Context>) => Container<TNewContext>\n  ): Container<MergeContext<Context, TNewKey, TNewContext>> {\n    return Container.build().group(key, decorator) as any\n  }\n\n  instance<TNewKey extends string, TValue>(\n    key: TNewKey,\n    ClassConstructor: Instance<TValue>,\n    ...args: any[]\n  ): Container<MergeContext<TContext, TNewKey, TValue>> {\n    this.register(key, (context) => new ClassConstructor(context, ...args))\n    return this as any\n  }\n\n  static instance<TNewKey extends string, TValue>(\n    key: TNewKey,\n    ClassConstructor: Instance<TValue>,\n    ...args: any[]\n  ): Container<MergeContext<Context, TNewKey, TValue>> {\n    return Container.build().instance(key, ClassConstructor, ...args) as any\n  }\n\n  register<TNewKey extends string, TValue>(\n    key: TNewKey,\n    resolver: (context: TContext, resolvedSet: CountingSet<unknown>) => TValue,\n    { transient }: RegistrationOptions = { transient: false }\n  ): Container<MergeContext<TContext, TNewKey, TValue>> {\n    if (transient) this._transient.add(key)\n    this._resolvers.set(key, resolver)\n    return this as any\n  }\n\n  static register<TNewKey extends string, TValue>(\n    key: TNewKey,\n    value: (context: Context) => TValue,\n    options?: RegistrationOptions\n  ): Container<MergeContext<Context, TNewKey, TValue>> {\n    return Container.build().register(key, value, options) as any\n  }\n\n  unregister<TNewKey extends string>(\n    key: TNewKey\n  ): Container<Omit<TContext, TNewKey>> {\n    this._resolvers.delete(key)\n    this._registry.delete(key)\n    this._transient.delete(key)\n\n    return this as any\n  }\n\n  static unregister<TNewKey extends string>(\n    key: TNewKey\n  ): Container<Omit<Context, TNewKey>> {\n    return Container.build().unregister(key) as any\n  }\n\n  resolve<T>(\n    key: keyof TContext,\n    resolved: CountingSet<unknown> = new CountingSet()\n  ): T {\n    if (this._registry.has(key as string)) {\n      return this._registry.get(key as string) as unknown as T\n    }\n\n    const resolver = this._resolvers.get(key as string)!\n    if (!resolver) return undefined as unknown as T\n    if (resolved.count(resolver) > 1) return undefined as unknown as T\n\n    const context = this.context(undefined, resolved.add(resolver))\n\n    const value = resolver(\n      this._parentContainer?.context(undefined, resolved) ?? context,\n      resolved.add(resolver)\n    ) as unknown as T\n\n    resolved.delete(resolver)\n\n    if (!this._transient.has(key as string)) {\n      this._registry.set(key as string, value)\n    }\n\n    return value\n  }\n}\n\ntype Serializable =\n  | null\n  | string\n  | number\n  | boolean\n  | undefined\n  | { [key: string]: Serializable }\n  | Serializable[]\n\nfunction handleCircularReferences(\n  obj: Serializable,\n  path: Serializable[] = []\n): Serializable {\n  if (obj === null) return null\n  if (typeof obj !== \"object\") return obj\n\n  const occurrence = path.filter((p) => p === obj).length\n\n  // If this object appears more than once in the current path, it's a circular reference.\n  if (occurrence > 1) {\n    return undefined\n  }\n\n  // path.push(obj)\n\n  let result: Serializable\n  if (Array.isArray(obj)) {\n    result = obj.map((item) =>\n      handleCircularReferences(item, path.slice())\n    ) as Serializable[]\n  } else {\n    result = {}\n    for (let key in obj) {\n      ;(result as any)[key] = handleCircularReferences(\n        (obj as any)[key],\n        path.slice()\n      )\n    }\n  }\n\n  path.pop()\n\n  return result\n}\n", "import { Context } from \"./Container\"\n\nexport class Injected<TContext extends Context> {\n  constructor(protected _context: TContext) {}\n}\n"],
  "mappings": "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",
  "names": []
}
