{
  "version": 3,
  "sources": ["../../src/CountingSet.ts", "../../src/Container.ts", "../../src/Singleton.ts"],
  "sourcesContent": ["export class CountingSet<T> {\n  private readonly _map = new Map<T, number>()\n  private readonly _set = new Set<T>()\n\n  add(value: T): this {\n    const count = this._map.get(value) || 0\n    this._map.set(value, count + 1)\n    this._set.add(value)\n    return this\n  }\n\n  delete(value: T): boolean {\n    if (this._map.has(value)) {\n      const count = this._map.get(value)!\n      if (count > 1) {\n        this._map.set(value, count - 1)\n      } else {\n        this._map.delete(value)\n        this._set.delete(value)\n      }\n      return true\n    }\n    return false\n  }\n\n  has(value: T): boolean {\n    return this._set.has(value)\n  }\n\n  count(value: T): number {\n    return this._map.get(value) || 0\n  }\n\n  clear(): void {\n    this._map.clear()\n    this._set.clear()\n  }\n\n  get size(): number {\n    return this._set.size\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    return this._set[Symbol.iterator]()\n  }\n\n  forEach(\n    callbackfn: (value: T, value2: T, set: Set<T>) => void,\n    thisArg?: any\n  ): void {\n    this._set.forEach(callbackfn, thisArg)\n  }\n}\n", "import { CountingSet } from \"./CountingSet\"\n\nexport type Context = {\n  [key: string]: unknown\n}\n\nexport type Instance<TValue> = {\n  new (context: any, ...args: any[]): TValue\n}\n\ntype Flatten<T> = {} & { [P in keyof T]: T[P] }\n\ntype AppendContext<TExisting, TKey extends string, TValue> = Flatten<\n  TExisting & {\n    [P in TKey]: TValue\n  }\n>\n\ntype RegistrationOptions = {\n  /**\n   * Turn on to resolve the factory and get a new value every single time.\n   *\n   * @example\n   * class RandomizerDependency {\n   *   constructor(public id = Math.floor(Math.random() * 1000)) {}\n   * }\n   *\n   * const context = Container.new()\n   *   .register(\"randomizer\", () => new RandomizerDependency(), { transient: true })\n   *   .context()\n   *\n   * console.log(context.randomizer.id) // => 123\n   * console.log(context.randomizer.id) // => 456\n   * console.log(context.randomizer.id) // => 789\n   */\n  transient?: boolean\n}\n/**\n * The `Container` is the core of nwire. It is responsible for registering and resolving dependencies.\n *\n * [**Container** API docs](https://github.com/divmgl/nwire/blob/master/packages/nwire/README.md#container).\n *\n * @example\n * ```ts\n * import { Container } from \"nwire\"\n *\n * // Create a new container\n * const container = Container.new()\n *\n * // Register a dependency\n * container.register(\"banner\", () => \"Hello world!\")\n *\n * // Resolve a dependency\n * const banner = container.resolve(\"banner\")\n * ```\n */\nexport class Container<TContext extends Context = {}> {\n  private _registry: Map<string, unknown> = new Map<string, unknown>()\n  private _resolvers: Map<string, (context: TContext) => unknown> = new Map<\n    string,\n    (context: TContext) => unknown\n  >()\n  private _cache: Map<(context: TContext) => unknown, unknown> = new Map()\n  private _transient: Set<string> = new Set<string>()\n  private _base: Record<string, unknown> = {}\n  private _rootContainer: Container | this\n  private _parentContainer: Container | this\n\n  /**\n   * Creates a new `Container`.\n   *\n   * @deprecated Use `Container.new()` instead.\n   * @hideconstructor\n   * @param rootContainer The root container. You'll never need to set this manually.\n   * @param parentContainer The parent container. You'll never need to set this manually.\n   */\n  constructor(rootContainer?: Container, parentContainer?: Container) {\n    this._rootContainer = rootContainer ?? this\n    this._parentContainer = parentContainer ?? this._rootContainer\n  }\n\n  /**\n   * The root container. You'll only ever need this if manually registering a dependency inside of a\n   * group.\n   *\n   * [**Container** API docs](https://github.com/divmgl/nwire/blob/master/packages/nwire/README.md#container).\n   *\n   * @example\n   * ```ts\n   * import { Container } from \"nwire\"\n   *\n   * const container = Container.new()\n   *   .group(\"services\", (container) =>\n   *     container.register(\"my\", () => new MyService(container.root.context()))\n   *   )\n   *   .context()\n   * ```\n   */\n  get root() {\n    return this._rootContainer\n  }\n\n  /**\n   * Populated with the parent container of a group container. You'll likely never need this.\n   */\n  protected get parent() {\n    return this._parentContainer\n  }\n\n  /**\n   * Shorthand for creating a container. Equivalent to `(new Container())`. Useful to start the\n   * chain in a fluent API call.\n   *\n   *\n   * @example\n   * import { Container } from \"nwire\"\n   *\n   * type AppContext = {\n   *   // ...\n   * }\n   *\n   * // All future registration factories will be type-safe\n   * const container = Container.new<AppContext>()\n   *   .register(\"my\", (context) => new MyService(context)) // context is AppContext\n   *\n   * @returns A new container\n   */\n  static new<T extends Context = {}>(): Container<T> {\n    return new Container<T>()\n  }\n\n  /**\n   * Alias for `Container.new()`.\n   *\n   * @deprecated Use `Container.new()` instead\n   */\n  static build<T extends Context = {}>() {\n    return Container.new<T>()\n  }\n\n  /**\n   * Adds a base to your context.\n   *\n   * Useful when there's expensive dependencies you'd rather create ahead of time. The proxy will always use the registered base as a fallback when keys are not found.\n   *\n   * *(Introduced in 1.1.2)*\n   *\n   * @param base The base to add to your context\n   *\n   * @example\n   * import { Container } from \"nwire\"\n   *\n   * const context = Container.new()\n   *   .base({ db: new Database() })\n   *   .register(\"my\", (context) => new MyService(context))\n   *   .context()\n   *\n   * expect(context.db).toEqual(context.db)\n   */\n  base<TBase extends Context>(base: TBase): Container<TContext & TBase> {\n    this._base = base\n    return this as any\n  }\n\n  private createContextProxy() {\n    const cache: Record<string, unknown> = {}\n    const resolving = new CountingSet<unknown>()\n\n    const handler = {\n      get: (target: TContext, key: string) => {\n        if (cache.hasOwnProperty(key)) return cache[key]\n        if (target.hasOwnProperty(key)) return target[key]\n\n        return resolve(key)\n      },\n      set: (_target: Context, key: string, value: unknown) => {\n        cache[key] = value\n        return true\n      },\n    }\n\n    const proxy = new Proxy({}, handler)\n\n    const resolve = <TValue>(key: keyof TContext) => {\n      const resolver = this._resolvers.get(key as string)!\n\n      if (this._registry.has(key as string)) {\n        resolving.delete(resolver)\n        return this._registry.get(key as string) as unknown as TValue\n      }\n\n      if (resolving.count(resolver) > 1) {\n        resolving.delete(resolver)\n        return this._cache.get(resolver) as unknown as TValue\n      }\n\n      const value = resolver?.(\n        this._rootContainer.context() as unknown as TContext\n      ) as unknown as TValue\n\n      resolving.delete(resolver)\n\n      if (this._transient.has(key as string)) return value\n\n      if (value) {\n        this._registry.set(key as string, value)\n        this._cache.set(resolver, value)\n      } else {\n        this.unregister(key as string)\n      }\n\n      return value\n    }\n\n    return proxy\n  }\n\n  /**\n   * Generates a `Context` object from the registered dependencies.\n   *\n   * [**Context** API docs](https://github.com/divmgl/nwire/blob/master/packages/nwire/README.md#context).\n   *\n   * @param override (optional) An object to override the context with. The override will always take precedence over registrations during resolution. Useful for testing.\n   *\n   * @example\n   * import { Container } from \"nwire\"\n   *\n   * const context = Container.new()\n   *   .register(\"banner\", () => \"Hello world!\")\n   *   .context()\n   *\n   * // Type of `context`\n   * const context = {\n   *   banner: string\n   * }\n   *\n   */\n  context<\n    TWriteContext extends Context = TContext,\n    TOverride extends Context = {}\n  >(override: TOverride | {} = {}): Flatten<TWriteContext & TOverride> {\n    // Get all of the keys for the resolvers in this container\n    const keys = Array.from(this._resolvers.keys())\n\n    const proxy = this.createContextProxy()\n\n    const context = keys.reduce(\n      (acc, key) => {\n        Object.defineProperty(acc, key, {\n          get: () => {\n            return proxy[key as keyof typeof proxy]\n          },\n          enumerable: true,\n        })\n\n        return acc\n      },\n      { ...this._base } as Flatten<TWriteContext & TOverride>\n    )\n\n    return Object.assign(context, override)\n  }\n\n  /**\n   * Add a group of dependencies to your container on a given key.\n   *\n   * A nested `Container` is created with its context automatically resolved during resolution.\n   *\n   * @param key The key to register the group on\n   * @param decorator A function that receives a new `Container` and returns a decorated `Container`\n   *\n   * @example\n   * import { Container } from \"nwire\"\n   *\n   * const context = Container.new()\n   *   .group(\"services\", (services) => services.singleton(\"my\", MyService))\n   *   .context()\n   *\n   * // Type of `context`\n   * const context = {\n   *   services: {\n   *     my: MyService\n   *   }\n   * }\n   */\n  group<TNewKey extends string, TNewContext extends Context>(\n    key: TNewKey,\n    decorator: (container: Container<{}>) => Container<TNewContext>\n  ) {\n    // Create a new container for the group on every resolution and set this container as the parent.\n    this.register(key, () => {\n      const groupContainer = // @ts-expect-error\n        decorator(new Container(this._rootContainer, this))\n      const groupContext = groupContainer.context()\n\n      const grouping = Array.from(groupContainer._resolvers.keys()).reduce(\n        (acc, key) => {\n          return Object.assign(acc, {\n            get [key]() {\n              return groupContext[key]\n            },\n          })\n        },\n        {} as TNewContext\n      )\n\n      this._registry.set(key as string, grouping)\n\n      return groupContainer.context()\n    })\n\n    return this as Container<TContext & { [key in TNewKey]: TNewContext }>\n  }\n\n  /**\n   * Registers a `Class` to be used as a factory to create a singleton.\n   *\n   * @param key The key to register the dependency on\n   * @param ClassConstructor The class constructor to use when resolving the singleton\n   * @param args Any additional arguments after the `Context` to pass to the class constructor\n   *\n   * @example\n   * import { Container } from \"nwire\"\n   *\n   * class MyService extends Service<AppContext>() {\n   *   constructor(context: AppContext) {\n   *     // ...\n   *   }\n   *\n   *   helloWorld() {\n   *     return this.banner\n   *   }\n   * }\n   *\n   * const context = Container.new()\n   *   .register(\"banner\", () => \"Hello world!\")\n   *   .singleton(\"my\", MyService)\n   *\n   * // Usage\n   * context.my.helloWorld() // => \"Hello world!\"\n   */\n  singleton<TNewKey extends string, TValue>(\n    key: TNewKey,\n    ClassConstructor: Instance<TValue>,\n    ...args: any[]\n  ) {\n    return this.register(\n      key,\n      (context) => new ClassConstructor(context, ...args)\n    )\n  }\n\n  /**\n   * Alias for `Container.singleton()`.\n   *\n   * @deprecated Use `Container.singleton()` instead.\n   */\n  instance<TNewKey extends string, TValue>(\n    key: TNewKey,\n    ClassConstructor: Instance<TValue>,\n    ...args: any[]\n  ) {\n    return this.singleton(key, ClassConstructor, ...args)\n  }\n\n  /**\n   * Registers a factory to use when resolving a dependency under a given key.\n   *\n   * `Container.prototype.group` and `Container.prototype.singleton` use this under the hood.\n   *\n   * @param key key to register the dependency on\n   * @param factory The factory that creates the dependency. Used during lazy resolution.\n   * @returns\n   */\n  register<TNewKey extends string, TValue>(\n    key: TNewKey,\n    factory: (context: TContext) => TValue,\n    { transient }: RegistrationOptions = { transient: false }\n  ): Container<AppendContext<TContext, TNewKey, TValue>> {\n    if (transient) this._transient.add(key)\n    this._resolvers.set(key, factory)\n    return this as any\n  }\n\n  /**\n   * Removes a dependency from the container on a given key.\n   *\n   * @param key key to unregister the dependency on\n   */\n  unregister<TNewKey extends string>(\n    key: TNewKey\n  ): Container<Omit<TContext, TNewKey>> {\n    this._resolvers.delete(key)\n    this._registry.delete(key)\n    this._transient.delete(key)\n\n    return this as any\n  }\n\n  /**\n   * Manually resolve a dependency on a given key.\n   *\n   * There aren't many use cases for invoking this method manually. It is used internally by the proxy created by `Container.prototype.context`.\n   *\n   * @param key key to resolve the dependency on\n   *\n   * @example\n   * import { Container } from \"nwire\"\n   *\n   * const container = Container.new()\n   *   .register(\"banner\", () => \"Hello world!\")\n   *   .context()\n   *\n   * container.resolve(\"banner\") // => \"Hello world!\"\n   */\n  resolve<TValue>(key: keyof TContext): TValue {\n    const resolver = this._resolvers.get(key as string)\n    if (!resolver) throw new Error(`dependency ${String(key)} not registered`)\n    return resolver(this._rootContainer.context() as TContext) as TValue\n  }\n\n  /**\n   * Send your container through a decorator function and capture the result. Useful when you want to create a decorator function that can be used in multiple places or more than once.\n   *\n   * @param pipe A function that receives a new `Container` and returns a decorated `Container`\n   *\n   * @example\n   * import { Container } from \"nwire\"\n   *\n   * function registerMap(name: string, map: Record<string, unknown>) {\n   *   return (container: Container) => {\n   *     return container.register(name, () => map)\n   *   }\n   * }\n   *\n   * let container = Container.new()\n   *\n   * for (const customerId of customerIds) {\n   *   container = container.pipe(\n   *     registerMap(`banner-${customerId}`, { banner: \"Hello world!\" })})\n   *   )\n   * }\n   *\n   * // Type of `context`\n   * let context = {\n   *   [\"banner-123\"]: string\n   *   [\"banner-456\"]: string\n   *   [\"banner-789\"]: string\n   * }\n   */\n  pipe<TNewContext extends Context>(\n    pipe: (container: Container<TContext>) => Container<TNewContext>\n  ) {\n    return pipe(this)\n  }\n}\n", "import { Context } from \"./Container\"\n\ntype PopulatedSingleton<T> = T & { [key in keyof T]: T[key] }\n\n// Mixin to add context-based properties to a class\nexport function Service<T extends Context>(\n  Base: any = Singleton\n): new (context: T) => PopulatedSingleton<T> {\n  return class extends Base {\n    constructor(context: T) {\n      super(context)\n\n      for (const key in context) {\n        Object.defineProperty(this, key, {\n          get: function () {\n            return context[key]\n          },\n          enumerable: true,\n        })\n      }\n    }\n  } as new (context: T) => PopulatedSingleton<T>\n}\n\nexport class Singleton<TContext extends Context> {\n  protected _context: TContext\n\n  constructor(context: TContext) {\n    this._context = context\n  }\n}\n"],
  "mappings": ";AAAO,IAAM,cAAN,MAAqB;AAAA,EACT,OAAO,oBAAI,IAAe;AAAA,EAC1B,OAAO,oBAAI,IAAO;AAAA,EAEnC,IAAI,OAAgB;AAClB,UAAM,QAAQ,KAAK,KAAK,IAAI,KAAK,KAAK;AACtC,SAAK,KAAK,IAAI,OAAO,QAAQ,CAAC;AAC9B,SAAK,KAAK,IAAI,KAAK;AACnB,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,OAAmB;AACxB,QAAI,KAAK,KAAK,IAAI,KAAK,GAAG;AACxB,YAAM,QAAQ,KAAK,KAAK,IAAI,KAAK;AACjC,UAAI,QAAQ,GAAG;AACb,aAAK,KAAK,IAAI,OAAO,QAAQ,CAAC;AAAA,MAChC,OAAO;AACL,aAAK,KAAK,OAAO,KAAK;AACtB,aAAK,KAAK,OAAO,KAAK;AAAA,MACxB;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,OAAmB;AACrB,WAAO,KAAK,KAAK,IAAI,KAAK;AAAA,EAC5B;AAAA,EAEA,MAAM,OAAkB;AACtB,WAAO,KAAK,KAAK,IAAI,KAAK,KAAK;AAAA,EACjC;AAAA,EAEA,QAAc;AACZ,SAAK,KAAK,MAAM;AAChB,SAAK,KAAK,MAAM;AAAA,EAClB;AAAA,EAEA,IAAI,OAAe;AACjB,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA,EAEA,CAAC,OAAO,QAAQ,IAAiB;AAC/B,WAAO,KAAK,KAAK,OAAO,QAAQ,EAAE;AAAA,EACpC;AAAA,EAEA,QACE,YACA,SACM;AACN,SAAK,KAAK,QAAQ,YAAY,OAAO;AAAA,EACvC;AACF;;;ACIO,IAAM,YAAN,MAAM,WAAyC;AAAA,EAC5C,YAAkC,oBAAI,IAAqB;AAAA,EAC3D,aAA0D,oBAAI,IAGpE;AAAA,EACM,SAAuD,oBAAI,IAAI;AAAA,EAC/D,aAA0B,oBAAI,IAAY;AAAA,EAC1C,QAAiC,CAAC;AAAA,EAClC;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUR,YAAY,eAA2B,iBAA6B;AAClE,SAAK,iBAAiB,iBAAiB;AACvC,SAAK,mBAAmB,mBAAmB,KAAK;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,IAAc,SAAS;AACrB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBA,OAAO,MAA4C;AACjD,WAAO,IAAI,WAAa;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,QAAgC;AACrC,WAAO,WAAU,IAAO;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,KAA4B,MAA0C;AACpE,SAAK,QAAQ;AACb,WAAO;AAAA,EACT;AAAA,EAEQ,qBAAqB;AAC3B,UAAM,QAAiC,CAAC;AACxC,UAAM,YAAY,IAAI,YAAqB;AAE3C,UAAM,UAAU;AAAA,MACd,KAAK,CAAC,QAAkB,QAAgB;AACtC,YAAI,MAAM,eAAe,GAAG;AAAG,iBAAO,MAAM,GAAG;AAC/C,YAAI,OAAO,eAAe,GAAG;AAAG,iBAAO,OAAO,GAAG;AAEjD,eAAO,QAAQ,GAAG;AAAA,MACpB;AAAA,MACA,KAAK,CAAC,SAAkB,KAAa,UAAmB;AACtD,cAAM,GAAG,IAAI;AACb,eAAO;AAAA,MACT;AAAA,IACF;AAEA,UAAM,QAAQ,IAAI,MAAM,CAAC,GAAG,OAAO;AAEnC,UAAM,UAAU,CAAS,QAAwB;AAC/C,YAAM,WAAW,KAAK,WAAW,IAAI,GAAa;AAElD,UAAI,KAAK,UAAU,IAAI,GAAa,GAAG;AACrC,kBAAU,OAAO,QAAQ;AACzB,eAAO,KAAK,UAAU,IAAI,GAAa;AAAA,MACzC;AAEA,UAAI,UAAU,MAAM,QAAQ,IAAI,GAAG;AACjC,kBAAU,OAAO,QAAQ;AACzB,eAAO,KAAK,OAAO,IAAI,QAAQ;AAAA,MACjC;AAEA,YAAM,QAAQ;AAAA,QACZ,KAAK,eAAe,QAAQ;AAAA;AAG9B,gBAAU,OAAO,QAAQ;AAEzB,UAAI,KAAK,WAAW,IAAI,GAAa;AAAG,eAAO;AAE/C,UAAI,OAAO;AACT,aAAK,UAAU,IAAI,KAAe,KAAK;AACvC,aAAK,OAAO,IAAI,UAAU,KAAK;AAAA,MACjC,OAAO;AACL,aAAK,WAAW,GAAa;AAAA,MAC/B;AAEA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,QAGE,WAA2B,CAAC,GAAuC;AAEnE,UAAM,OAAO,MAAM,KAAK,KAAK,WAAW,KAAK,CAAC;AAE9C,UAAM,QAAQ,KAAK,mBAAmB;AAEtC,UAAM,UAAU,KAAK;AAAA,MACnB,CAAC,KAAK,QAAQ;AACZ,eAAO,eAAe,KAAK,KAAK;AAAA,UAC9B,KAAK,MAAM;AACT,mBAAO,MAAM,GAAyB;AAAA,UACxC;AAAA,UACA,YAAY;AAAA,QACd,CAAC;AAED,eAAO;AAAA,MACT;AAAA,MACA,EAAE,GAAG,KAAK,MAAM;AAAA,IAClB;AAEA,WAAO,OAAO,OAAO,SAAS,QAAQ;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,MACE,KACA,WACA;AAEA,SAAK,SAAS,KAAK,MAAM;AACvB,YAAM;AAAA;AAAA,QACJ,UAAU,IAAI,WAAU,KAAK,gBAAgB,IAAI,CAAC;AAAA;AACpD,YAAM,eAAe,eAAe,QAAQ;AAE5C,YAAM,WAAW,MAAM,KAAK,eAAe,WAAW,KAAK,CAAC,EAAE;AAAA,QAC5D,CAAC,KAAKA,SAAQ;AACZ,iBAAO,OAAO,OAAO,KAAK;AAAA,YACxB,KAAKA,IAAG,IAAI;AACV,qBAAO,aAAaA,IAAG;AAAA,YACzB;AAAA,UACF,CAAC;AAAA,QACH;AAAA,QACA,CAAC;AAAA,MACH;AAEA,WAAK,UAAU,IAAI,KAAe,QAAQ;AAE1C,aAAO,eAAe,QAAQ;AAAA,IAChC,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BA,UACE,KACA,qBACG,MACH;AACA,WAAO,KAAK;AAAA,MACV;AAAA,MACA,CAAC,YAAY,IAAI,iBAAiB,SAAS,GAAG,IAAI;AAAA,IACpD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SACE,KACA,qBACG,MACH;AACA,WAAO,KAAK,UAAU,KAAK,kBAAkB,GAAG,IAAI;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,SACE,KACA,SACA,EAAE,UAAU,IAAyB,EAAE,WAAW,MAAM,GACH;AACrD,QAAI;AAAW,WAAK,WAAW,IAAI,GAAG;AACtC,SAAK,WAAW,IAAI,KAAK,OAAO;AAChC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WACE,KACoC;AACpC,SAAK,WAAW,OAAO,GAAG;AAC1B,SAAK,UAAU,OAAO,GAAG;AACzB,SAAK,WAAW,OAAO,GAAG;AAE1B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,QAAgB,KAA6B;AAC3C,UAAM,WAAW,KAAK,WAAW,IAAI,GAAa;AAClD,QAAI,CAAC;AAAU,YAAM,IAAI,MAAM,cAAc,OAAO,GAAG,CAAC,iBAAiB;AACzE,WAAO,SAAS,KAAK,eAAe,QAAQ,CAAa;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BA,KACE,MACA;AACA,WAAO,KAAK,IAAI;AAAA,EAClB;AACF;;;AClcO,SAAS,QACd,OAAY,WAC+B;AAC3C,SAAO,cAAc,KAAK;AAAA,IACxB,YAAY,SAAY;AACtB,YAAM,OAAO;AAEb,iBAAW,OAAO,SAAS;AACzB,eAAO,eAAe,MAAM,KAAK;AAAA,UAC/B,KAAK,WAAY;AACf,mBAAO,QAAQ,GAAG;AAAA,UACpB;AAAA,UACA,YAAY;AAAA,QACd,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,YAAN,MAA0C;AAAA,EACrC;AAAA,EAEV,YAAY,SAAmB;AAC7B,SAAK,WAAW;AAAA,EAClB;AACF;",
  "names": ["key"]
}
