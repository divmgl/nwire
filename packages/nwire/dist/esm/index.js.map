{
  "version": 3,
  "sources": ["../../src/Container.ts", "../../src/Injected.ts"],
  "sourcesContent": ["export type Context = {\n  [key: string]: unknown\n}\nexport type Instance<TValue> = {\n  new (context: any, ...args: any[]): TValue\n}\n\ntype Flatten<T> = {} & { [P in keyof T]: T[P] }\n\ntype MergeContext<TExisting, TKey extends string, TValue> = Flatten<\n  TExisting & {\n    [P in TKey]: TValue\n  }\n>\n\ntype RegistrationOptions = {\n  transient?: boolean\n}\n\nexport class Container<TContext extends Context = {}> {\n  private _registry: Map<string, unknown>\n  private _map: Map<string, (context: TContext) => unknown>\n  private _transient: Set<string>\n\n  constructor(private _parentContainer?: Container<TContext>) {\n    this._transient = new Set<string>()\n    this._registry = new Map<string, unknown>()\n    this._map = new Map<string, (context: TContext) => unknown>()\n  }\n\n  static build<T extends Context = {}>(): Container<T> {\n    return new Container<T>()\n  }\n\n  copy<TContext>(rootContext: Context = {}): TContext {\n    // Get all of the keys in the map\n    const keys = Array.from(this._map.keys())\n\n    // Create an object that either has the value from the root context, the value from the registry\n    // or gets the value from the map's generator.\n    const context = keys.reduce((acc: Record<string, unknown>, key) => {\n      if (rootContext.hasOwnProperty(key)) {\n        acc[key] = rootContext[key]\n      } else if (this._registry.has(key)) {\n        acc[key] = this._registry.get(key)\n      } else {\n        acc[key] = this._map.get(key)!(this.context())\n      }\n\n      return acc\n    }, {}) as TContext\n\n    return {\n      ...rootContext,\n      ...(handleCircularReferences(\n        context as unknown as Serializable\n      ) as TContext),\n    }\n  }\n\n  context<TWriteContext extends Context = TContext>(\n    rootContext: Context = {},\n    resolving: Set<unknown> = new Set<unknown>()\n  ): TWriteContext {\n    const cache: Record<string, unknown> = {}\n\n    const handler = {\n      get: (target: Context, key: string) => {\n        const generator = this._map.get(key)!\n        if (resolving.has(generator)) return undefined\n        if (cache.hasOwnProperty(key)) return cache[key]\n        if (rootContext.hasOwnProperty(key)) return rootContext[key]\n        if (!this._map.has(key)) return target[key]\n        if (this._registry.has(key)) return this._registry.get(key)\n\n        resolving.add(generator)\n        const instance = generator(this.context(rootContext, resolving))\n        resolving.delete(generator)\n        if (!this._transient.has(key)) this._registry.set(key, instance)\n\n        return instance\n      },\n      set: (target: Context, key: string, value: unknown) => {\n        cache[key] = value\n        return true\n      },\n    }\n\n    const proxy = new Proxy<TContext>({} as TContext, handler)\n\n    return proxy as unknown as TWriteContext\n  }\n\n  // Add a subcontext to a property of this context\n  group<TNewKey extends string, TNewContext extends Context>(\n    key: TNewKey,\n    decorator: (container: Container<TContext>) => Container<TNewContext>\n  ): Container<MergeContext<TContext, TNewKey, TNewContext>> {\n    const nestedContainer = new Container(this._parentContainer ?? this)\n    const value = decorator(nestedContainer).context()\n    this.register(key, () => value)\n    return this as any\n  }\n\n  static group<TNewKey extends string, TNewContext extends Context>(\n    key: TNewKey,\n    decorator: (container: Container<Context>) => Container<TNewContext>\n  ): Container<MergeContext<Context, TNewKey, TNewContext>> {\n    return Container.build().group(key, decorator) as any\n  }\n\n  instance<TNewKey extends string, TValue>(\n    key: TNewKey,\n    ValueClass: Instance<TValue>,\n    ...args: any[]\n  ): Container<MergeContext<TContext, TNewKey, TValue>> {\n    this._map.set(\n      key,\n      () => new ValueClass((this._parentContainer ?? this).context(), ...args)\n    )\n    return this as any\n  }\n\n  static instance<TNewKey extends string, TValue>(\n    key: TNewKey,\n    ValueClass: Instance<TValue>,\n    ...args: any[]\n  ): Container<MergeContext<Context, TNewKey, TValue>> {\n    return Container.build().instance(key, ValueClass, ...args) as any\n  }\n\n  register<TNewKey extends string, TValue>(\n    key: TNewKey,\n    value: (context: TContext) => TValue,\n    { transient }: RegistrationOptions = { transient: false }\n  ): Container<MergeContext<TContext, TNewKey, TValue>> {\n    this._map.set(key, () =>\n      value(\n        (this._parentContainer ?? this).context() as MergeContext<\n          TContext,\n          TNewKey,\n          TValue\n        >\n      )\n    )\n\n    if (transient) this._transient.add(key)\n\n    return this as any\n  }\n\n  static register<TNewKey extends string, TValue>(\n    key: TNewKey,\n    value: (context: Context) => TValue,\n    options?: RegistrationOptions\n  ): Container<MergeContext<Context, TNewKey, TValue>> {\n    return Container.build().register(key, value, options) as any\n  }\n\n  unregister<TNewKey extends string>(\n    key: TNewKey\n  ): Container<Omit<TContext, TNewKey>> {\n    this._map.delete(key)\n    this._registry.delete(key)\n    this._transient.delete(key)\n\n    return this as any\n  }\n\n  static unregister<TNewKey extends string>(\n    key: TNewKey\n  ): Container<Omit<Context, TNewKey>> {\n    return Container.build().unregister(key) as any\n  }\n\n  resolve<T>(key: keyof TContext): T {\n    return this._map.get(key as string)?.(this.context()) as unknown as T\n  }\n}\n\ntype Serializable =\n  | null\n  | string\n  | number\n  | boolean\n  | undefined\n  | { [key: string]: Serializable }\n  | Serializable[]\n\nfunction handleCircularReferences(\n  obj: Serializable,\n  path: Serializable[] = []\n): Serializable {\n  if (obj === null) return null\n  if (typeof obj !== \"object\") return obj\n\n  const occurrence = path.filter((p) => p === obj).length\n\n  // If this object appears more than once in the current path, it's a circular reference.\n  if (occurrence > 1) {\n    return undefined\n  }\n\n  path.push(obj)\n\n  let result: Serializable\n  if (Array.isArray(obj)) {\n    result = obj.map((item) =>\n      handleCircularReferences(item, path.slice())\n    ) as Serializable[]\n  } else {\n    result = {}\n    for (let key in obj) {\n      ;(result as any)[key] = handleCircularReferences(\n        (obj as any)[key],\n        path.slice()\n      )\n    }\n  }\n\n  path.pop()\n\n  return result\n}\n", "import { Context } from \"./Container\"\n\nexport class Injected<TContext extends Context> {\n  constructor(protected _context: TContext) {}\n}\n"],
  "mappings": "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",
  "names": []
}
